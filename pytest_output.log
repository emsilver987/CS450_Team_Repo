...F........s........................................................... [ 28%]
..................F..................................................... [ 56%]
........................................................................ [ 84%]
..............F........................                                  [100%]
=================================== FAILURES ===================================
_________ TestAnalyzeLocalRepoCoverage.test_get_git_metadata_exception _________

self = <test_analyze_local_repo_coverage.TestAnalyzeLocalRepoCoverage object at 0x7fda8fda5cd0>

    def test_get_git_metadata_exception(self):
        """Test get_git_metadata when exception occurs."""
        with tempfile.TemporaryDirectory() as temp_dir:
            # Create a directory that's not a git repo
>           result = get_git_metadata(temp_dir)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_analyze_local_repo_coverage.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ai_model_catalog/analyze_local_repo.py:58: in get_git_metadata
    repo = Repo(repo_path)
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Repo' object has no attribute 'git_dir'") raised in repr()] Repo object at 0x7fda8fc19e80>
path = '/tmp/tmpoaw_aey2', odbt = <class 'git.db.GitCmdObjectDB'>
search_parent_directories = False, expand_vars = True

    def __init__(
        self,
        path: Optional[PathLike] = None,
        odbt: Type[LooseObjectDB] = GitCmdObjectDB,
        search_parent_directories: bool = False,
        expand_vars: bool = True,
    ) -> None:
        R"""Create a new :class:`Repo` instance.
    
        :param path:
            The path to either the worktree directory or the .git directory itself::
    
                repo = Repo("/Users/mtrier/Development/git-python")
                repo = Repo("/Users/mtrier/Development/git-python.git")
                repo = Repo("~/Development/git-python.git")
                repo = Repo("$REPOSITORIES/Development/git-python.git")
                repo = Repo(R"C:\Users\mtrier\Development\git-python\.git")
    
            - In *Cygwin*, `path` may be a ``cygdrive/...`` prefixed path.
            - If `path` is ``None`` or an empty string, :envvar:`GIT_DIR` is used. If
              that environment variable is absent or empty, the current directory is
              used.
    
        :param odbt:
            Object DataBase type - a type which is constructed by providing the
            directory containing the database objects, i.e. ``.git/objects``. It will be
            used to access all object data.
    
        :param search_parent_directories:
            If ``True``, all parent directories will be searched for a valid repo as
            well.
    
            Please note that this was the default behaviour in older versions of
            GitPython, which is considered a bug though.
    
        :raise git.exc.InvalidGitRepositoryError:
    
        :raise git.exc.NoSuchPathError:
    
        :return:
            :class:`Repo`
        """
    
        epath = path or os.getenv("GIT_DIR")
        if not epath:
            epath = os.getcwd()
        if Git.is_cygwin():
            # Given how the tests are written, this seems more likely to catch Cygwin
            # git used from Windows than Windows git used from Cygwin. Therefore
            # changing to Cygwin-style paths is the relevant operation.
            epath = cygpath(str(epath))
    
        epath = epath or path or os.getcwd()
        if not isinstance(epath, str):
            epath = str(epath)
        if expand_vars and re.search(self.re_envvars, epath):
            warnings.warn(
                "The use of environment variables in paths is deprecated"
                + "\nfor security reasons and may be removed in the future!!",
                stacklevel=1,
            )
        epath = expand_path(epath, expand_vars)
        if epath is not None:
            if not os.path.exists(epath):
                raise NoSuchPathError(epath)
    
        # Walk up the path to find the `.git` dir.
        curpath = epath
        git_dir = None
        while curpath:
            # ABOUT osp.NORMPATH
            # It's important to normalize the paths, as submodules will otherwise
            # initialize their repo instances with paths that depend on path-portions
            # that will not exist after being removed. It's just cleaner.
            if is_git_dir(curpath):
                git_dir = curpath
                # from man git-config : core.worktree
                # Set the path to the root of the working tree. If GIT_COMMON_DIR
                # environment variable is set, core.worktree is ignored and not used for
                # determining the root of working tree. This can be overridden by the
                # GIT_WORK_TREE environment variable. The value can be an absolute path
                # or relative to the path to the .git directory, which is either
                # specified by GIT_DIR, or automatically discovered. If GIT_DIR is
                # specified but none of GIT_WORK_TREE and core.worktree is specified,
                # the current working directory is regarded as the top level of your
                # working tree.
                self._working_tree_dir = os.path.dirname(git_dir)
                if os.environ.get("GIT_COMMON_DIR") is None:
                    gitconf = self._config_reader("repository", git_dir)
                    if gitconf.has_option("core", "worktree"):
                        self._working_tree_dir = gitconf.get("core", "worktree")
                if "GIT_WORK_TREE" in os.environ:
                    self._working_tree_dir = os.getenv("GIT_WORK_TREE")
                break
    
            dotgit = osp.join(curpath, ".git")
            sm_gitpath = find_submodule_git_dir(dotgit)
            if sm_gitpath is not None:
                git_dir = osp.normpath(sm_gitpath)
    
            sm_gitpath = find_submodule_git_dir(dotgit)
            if sm_gitpath is None:
                sm_gitpath = find_worktree_git_dir(dotgit)
    
            if sm_gitpath is not None:
                git_dir = expand_path(sm_gitpath, expand_vars)
                self._working_tree_dir = curpath
                break
    
            if not search_parent_directories:
                break
            curpath, tail = osp.split(curpath)
            if not tail:
                break
        # END while curpath
    
        if git_dir is None:
>           raise InvalidGitRepositoryError(epath)
E           git.exc.InvalidGitRepositoryError: /tmp/tmpoaw_aey2

/home/ethansilverthorne/.local/lib/python3.12/site-packages/git/repo/base.py:289: InvalidGitRepositoryError
______________________________ test_network_debug ______________________________

    def test_network_debug():
        """Main test function."""
        debugger = NetworkDebugger()
>       results = debugger.run_all_tests()
                  ^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_network_debug.py:320: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_network_debug.py:298: in run_all_tests
    "model_scoring": self.test_model_scoring(),
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
tests/test_network_debug.py:251: in test_model_scoring
    result = score_model_from_id(model_id)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ai_model_catalog/score_model.py:178: in score_model_from_id
    local_data = analyze_hf_repo(model_id)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
src/ai_model_catalog/analyze_local_repo.py:83: in analyze_hf_repo
    git_data = get_git_metadata(repo_path)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ai_model_catalog/analyze_local_repo.py:58: in get_git_metadata
    repo = Repo(repo_path)
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Repo' object has no attribute 'git_dir'") raised in repr()] Repo object at 0x7fda91ed1970>
path = 'cloned_models/google-bert_bert-base-uncased'
odbt = <class 'git.db.GitCmdObjectDB'>, search_parent_directories = False
expand_vars = True

    def __init__(
        self,
        path: Optional[PathLike] = None,
        odbt: Type[LooseObjectDB] = GitCmdObjectDB,
        search_parent_directories: bool = False,
        expand_vars: bool = True,
    ) -> None:
        R"""Create a new :class:`Repo` instance.
    
        :param path:
            The path to either the worktree directory or the .git directory itself::
    
                repo = Repo("/Users/mtrier/Development/git-python")
                repo = Repo("/Users/mtrier/Development/git-python.git")
                repo = Repo("~/Development/git-python.git")
                repo = Repo("$REPOSITORIES/Development/git-python.git")
                repo = Repo(R"C:\Users\mtrier\Development\git-python\.git")
    
            - In *Cygwin*, `path` may be a ``cygdrive/...`` prefixed path.
            - If `path` is ``None`` or an empty string, :envvar:`GIT_DIR` is used. If
              that environment variable is absent or empty, the current directory is
              used.
    
        :param odbt:
            Object DataBase type - a type which is constructed by providing the
            directory containing the database objects, i.e. ``.git/objects``. It will be
            used to access all object data.
    
        :param search_parent_directories:
            If ``True``, all parent directories will be searched for a valid repo as
            well.
    
            Please note that this was the default behaviour in older versions of
            GitPython, which is considered a bug though.
    
        :raise git.exc.InvalidGitRepositoryError:
    
        :raise git.exc.NoSuchPathError:
    
        :return:
            :class:`Repo`
        """
    
        epath = path or os.getenv("GIT_DIR")
        if not epath:
            epath = os.getcwd()
        if Git.is_cygwin():
            # Given how the tests are written, this seems more likely to catch Cygwin
            # git used from Windows than Windows git used from Cygwin. Therefore
            # changing to Cygwin-style paths is the relevant operation.
            epath = cygpath(str(epath))
    
        epath = epath or path or os.getcwd()
        if not isinstance(epath, str):
            epath = str(epath)
        if expand_vars and re.search(self.re_envvars, epath):
            warnings.warn(
                "The use of environment variables in paths is deprecated"
                + "\nfor security reasons and may be removed in the future!!",
                stacklevel=1,
            )
        epath = expand_path(epath, expand_vars)
        if epath is not None:
            if not os.path.exists(epath):
                raise NoSuchPathError(epath)
    
        # Walk up the path to find the `.git` dir.
        curpath = epath
        git_dir = None
        while curpath:
            # ABOUT osp.NORMPATH
            # It's important to normalize the paths, as submodules will otherwise
            # initialize their repo instances with paths that depend on path-portions
            # that will not exist after being removed. It's just cleaner.
            if is_git_dir(curpath):
                git_dir = curpath
                # from man git-config : core.worktree
                # Set the path to the root of the working tree. If GIT_COMMON_DIR
                # environment variable is set, core.worktree is ignored and not used for
                # determining the root of working tree. This can be overridden by the
                # GIT_WORK_TREE environment variable. The value can be an absolute path
                # or relative to the path to the .git directory, which is either
                # specified by GIT_DIR, or automatically discovered. If GIT_DIR is
                # specified but none of GIT_WORK_TREE and core.worktree is specified,
                # the current working directory is regarded as the top level of your
                # working tree.
                self._working_tree_dir = os.path.dirname(git_dir)
                if os.environ.get("GIT_COMMON_DIR") is None:
                    gitconf = self._config_reader("repository", git_dir)
                    if gitconf.has_option("core", "worktree"):
                        self._working_tree_dir = gitconf.get("core", "worktree")
                if "GIT_WORK_TREE" in os.environ:
                    self._working_tree_dir = os.getenv("GIT_WORK_TREE")
                break
    
            dotgit = osp.join(curpath, ".git")
            sm_gitpath = find_submodule_git_dir(dotgit)
            if sm_gitpath is not None:
                git_dir = osp.normpath(sm_gitpath)
    
            sm_gitpath = find_submodule_git_dir(dotgit)
            if sm_gitpath is None:
                sm_gitpath = find_worktree_git_dir(dotgit)
    
            if sm_gitpath is not None:
                git_dir = expand_path(sm_gitpath, expand_vars)
                self._working_tree_dir = curpath
                break
    
            if not search_parent_directories:
                break
            curpath, tail = osp.split(curpath)
            if not tail:
                break
        # END while curpath
    
        if git_dir is None:
>           raise InvalidGitRepositoryError(epath)
E           git.exc.InvalidGitRepositoryError: /mnt/c/Main Local Folder/Fall 2025/CSCI 450/CS450 Proj/CS450_Team_Repo/cloned_models/google-bert_bert-base-uncased

/home/ethansilverthorne/.local/lib/python3.12/site-packages/git/repo/base.py:289: InvalidGitRepositoryError
----------------------------- Captured stdout call -----------------------------
🔍 Starting Network Debug Tests...
==================================================

=== Testing Basic Connectivity ===
✓ https://httpbin.org/get: 200 (327ms)
✓ https://api.github.com: 200 (217ms)
✓ https://huggingface.co/api: 404 (192ms)

=== Testing Hugging Face API ===
✓ HF API: 200 (74ms)
  Model: google-bert/bert-base-uncased
  Author: google-bert
  Downloads: 54,229,912
  Has README: False

=== Testing GitHub API ===
✓ GitHub API: 200 (134ms)
  User: emsilver987
  Rate limit remaining: 4850

=== Testing LLM Service ===

=== Testing Model Scoring ===
__________________________ test_model_scoring_timing ___________________________

    def test_model_scoring_timing():
        """Test the actual model scoring timing."""
        print("\n📊 Testing model scoring timing...")
    
        try:
            from ai_model_catalog.score_model import score_model_from_id
    
            model_id = "google-bert/bert-base-uncased"
    
            # Test multiple times to get average
            times = []
            for i in range(3):
                start = time.time()
                try:
>                   result = score_model_from_id(model_id)
                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_timeouts.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/ai_model_catalog/score_model.py:178: in score_model_from_id
    local_data = analyze_hf_repo(model_id)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^
src/ai_model_catalog/analyze_local_repo.py:83: in analyze_hf_repo
    git_data = get_git_metadata(repo_path)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/ai_model_catalog/analyze_local_repo.py:58: in get_git_metadata
    repo = Repo(repo_path)
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <[AttributeError("'Repo' object has no attribute 'git_dir'") raised in repr()] Repo object at 0x7fda8f75af30>
path = 'cloned_models/google-bert_bert-base-uncased'
odbt = <class 'git.db.GitCmdObjectDB'>, search_parent_directories = False
expand_vars = True

    def __init__(
        self,
        path: Optional[PathLike] = None,
        odbt: Type[LooseObjectDB] = GitCmdObjectDB,
        search_parent_directories: bool = False,
        expand_vars: bool = True,
    ) -> None:
        R"""Create a new :class:`Repo` instance.
    
        :param path:
            The path to either the worktree directory or the .git directory itself::
    
                repo = Repo("/Users/mtrier/Development/git-python")
                repo = Repo("/Users/mtrier/Development/git-python.git")
                repo = Repo("~/Development/git-python.git")
                repo = Repo("$REPOSITORIES/Development/git-python.git")
                repo = Repo(R"C:\Users\mtrier\Development\git-python\.git")
    
            - In *Cygwin*, `path` may be a ``cygdrive/...`` prefixed path.
            - If `path` is ``None`` or an empty string, :envvar:`GIT_DIR` is used. If
              that environment variable is absent or empty, the current directory is
              used.
    
        :param odbt:
            Object DataBase type - a type which is constructed by providing the
            directory containing the database objects, i.e. ``.git/objects``. It will be
            used to access all object data.
    
        :param search_parent_directories:
            If ``True``, all parent directories will be searched for a valid repo as
            well.
    
            Please note that this was the default behaviour in older versions of
            GitPython, which is considered a bug though.
    
        :raise git.exc.InvalidGitRepositoryError:
    
        :raise git.exc.NoSuchPathError:
    
        :return:
            :class:`Repo`
        """
    
        epath = path or os.getenv("GIT_DIR")
        if not epath:
            epath = os.getcwd()
        if Git.is_cygwin():
            # Given how the tests are written, this seems more likely to catch Cygwin
            # git used from Windows than Windows git used from Cygwin. Therefore
            # changing to Cygwin-style paths is the relevant operation.
            epath = cygpath(str(epath))
    
        epath = epath or path or os.getcwd()
        if not isinstance(epath, str):
            epath = str(epath)
        if expand_vars and re.search(self.re_envvars, epath):
            warnings.warn(
                "The use of environment variables in paths is deprecated"
                + "\nfor security reasons and may be removed in the future!!",
                stacklevel=1,
            )
        epath = expand_path(epath, expand_vars)
        if epath is not None:
            if not os.path.exists(epath):
                raise NoSuchPathError(epath)
    
        # Walk up the path to find the `.git` dir.
        curpath = epath
        git_dir = None
        while curpath:
            # ABOUT osp.NORMPATH
            # It's important to normalize the paths, as submodules will otherwise
            # initialize their repo instances with paths that depend on path-portions
            # that will not exist after being removed. It's just cleaner.
            if is_git_dir(curpath):
                git_dir = curpath
                # from man git-config : core.worktree
                # Set the path to the root of the working tree. If GIT_COMMON_DIR
                # environment variable is set, core.worktree is ignored and not used for
                # determining the root of working tree. This can be overridden by the
                # GIT_WORK_TREE environment variable. The value can be an absolute path
                # or relative to the path to the .git directory, which is either
                # specified by GIT_DIR, or automatically discovered. If GIT_DIR is
                # specified but none of GIT_WORK_TREE and core.worktree is specified,
                # the current working directory is regarded as the top level of your
                # working tree.
                self._working_tree_dir = os.path.dirname(git_dir)
                if os.environ.get("GIT_COMMON_DIR") is None:
                    gitconf = self._config_reader("repository", git_dir)
                    if gitconf.has_option("core", "worktree"):
                        self._working_tree_dir = gitconf.get("core", "worktree")
                if "GIT_WORK_TREE" in os.environ:
                    self._working_tree_dir = os.getenv("GIT_WORK_TREE")
                break
    
            dotgit = osp.join(curpath, ".git")
            sm_gitpath = find_submodule_git_dir(dotgit)
            if sm_gitpath is not None:
                git_dir = osp.normpath(sm_gitpath)
    
            sm_gitpath = find_submodule_git_dir(dotgit)
            if sm_gitpath is None:
                sm_gitpath = find_worktree_git_dir(dotgit)
    
            if sm_gitpath is not None:
                git_dir = expand_path(sm_gitpath, expand_vars)
                self._working_tree_dir = curpath
                break
    
            if not search_parent_directories:
                break
            curpath, tail = osp.split(curpath)
            if not tail:
                break
        # END while curpath
    
        if git_dir is None:
>           raise InvalidGitRepositoryError(epath)
E           git.exc.InvalidGitRepositoryError: /mnt/c/Main Local Folder/Fall 2025/CSCI 450/CS450 Proj/CS450_Team_Repo/cloned_models/google-bert_bert-base-uncased

/home/ethansilverthorne/.local/lib/python3.12/site-packages/git/repo/base.py:289: InvalidGitRepositoryError
----------------------------- Captured stdout call -----------------------------

📊 Testing model scoring timing...
=========================== short test summary info ============================
FAILED tests/test_analyze_local_repo_coverage.py::TestAnalyzeLocalRepoCoverage::test_get_git_metadata_exception
FAILED tests/test_network_debug.py::test_network_debug - git.exc.InvalidGitRe...
FAILED tests/test_timeouts.py::test_model_scoring_timing - git.exc.InvalidGit...
3 failed, 251 passed, 1 skipped in 18.38s
