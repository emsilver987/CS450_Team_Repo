#!/usr/bin/env bash
# Ultra-robust AI Model Catalog CLI - Auto-Grader Interface
# Handles all edge cases for auto-grader environment

set -euo pipefail

# Output colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Logging
log_info()  { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn()  { echo -e "${YELLOW}[WARNING]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# Ultra-robust Python detection
find_python() {
    # Try multiple Python paths in order of preference
    local python_paths=(
        ".venv/bin/python"
        "python3"
        "python"
        "/usr/bin/python3"
        "/usr/bin/python"
        "/usr/local/bin/python3"
        "/usr/local/bin/python"
    )
    
    for py in "${python_paths[@]}"; do
        if command -v "$py" &>/dev/null; then
            if $py -c "import sys; print('Python OK')" &>/dev/null 2>&1; then
                echo "$py"
                return 0
            fi
        fi
    done
    
    # Last resort: try to find python in PATH
    if command -v python3 &>/dev/null; then
        echo "python3"
        return 0
    elif command -v python &>/dev/null; then
        echo "python"
        return 0
    fi
    
    return 1
}

# Ultra-robust pip detection
find_pip() {
    local pip_paths=(
        ".venv/bin/pip"
        "pip3"
        "pip"
        "/usr/bin/pip3"
        "/usr/bin/pip"
        "/usr/local/bin/pip3"
        "/usr/local/bin/pip"
    )
    
    for pip in "${pip_paths[@]}"; do
        if command -v "$pip" &>/dev/null; then
            echo "$pip"
            return 0
        fi
    done
    
    return 1
}

# Check Python and packages
check_python() {
    PYTHON_CMD=$(find_python)
    if [[ -z "$PYTHON_CMD" ]]; then
        log_error "Python is required but not installed."
        exit 1
    fi
    
    # Test Python functionality
    if ! $PYTHON_CMD -c "import sys; print('Python OK')" &>/dev/null 2>&1; then
        log_error "Python is not working properly."
        exit 1
    fi
}

# Install dependencies with multiple fallback strategies
install_deps() {
    log_info "Installing Python dependencies..."
    
    # Try to find pip
    PIP_CMD=$(find_pip)
    if [[ -z "$PIP_CMD" ]]; then
        log_error "pip is not installed."
        exit 1
    fi
    
    # Try multiple installation strategies
    local install_success=false
    
    # Strategy 1: Standard install
    if $PIP_CMD install -e . >/dev/null 2>&1; then
        install_success=true
    fi
    
    # Strategy 2: Install with --break-system-packages (for externally managed environments)
    if [[ "$install_success" == false ]]; then
        if $PIP_CMD install -e . --break-system-packages >/dev/null 2>&1; then
            install_success=true
        fi
    fi
    
    # Strategy 3: Install without editable mode
    if [[ "$install_success" == false ]]; then
        if $PIP_CMD install . >/dev/null 2>&1; then
            install_success=true
        fi
    fi
    
    # Strategy 4: Install requirements only
    if [[ "$install_success" == false ]]; then
        if [[ -f "requirements.txt" ]]; then
            if $PIP_CMD install -r requirements.txt >/dev/null 2>&1; then
                install_success=true
            fi
        fi
    fi
    
    if [[ "$install_success" == true ]]; then
        log_info "Dependencies installed successfully."
        exit 0
    else
        log_error "Dependency installation failed."
        exit 1
    fi
}

# Run tests with multiple fallback strategies
run_tests() {
    log_info "Running tests and checking code coverage..."
    
    PYTHON_CMD=$(find_python)
    
    # Try multiple test runners with coverage
    local test_success=false
    local coverage_cmd=""
    
    # Strategy 1: Virtual environment coverage + pytest
    if [[ -f ".venv/bin/coverage" ]] && [[ -f ".venv/bin/pytest" ]]; then
        if .venv/bin/coverage run -m pytest tests >/dev/null 2>&1; then
            test_success=true
            coverage_cmd=".venv/bin/coverage"
        fi
    fi
    
    # Strategy 2: System coverage + pytest
    if [[ "$test_success" == false ]] && command -v coverage &>/dev/null && command -v pytest &>/dev/null; then
        if coverage run -m pytest tests >/dev/null 2>&1; then
            test_success=true
            coverage_cmd="coverage"
        fi
    fi
    
    # Strategy 3: Python module coverage + pytest
    if [[ "$test_success" == false ]]; then
        if $PYTHON_CMD -m coverage run -m pytest tests >/dev/null 2>&1; then
            test_success=true
            coverage_cmd="$PYTHON_CMD -m coverage"
        fi
    fi
    
    # Strategy 4: Just pytest (no coverage)
    if [[ "$test_success" == false ]] && command -v pytest &>/dev/null; then
        if pytest tests >/dev/null 2>&1; then
            test_success=true
        fi
    fi
    
    # Strategy 5: Python module pytest (no coverage)
    if [[ "$test_success" == false ]]; then
        if $PYTHON_CMD -m pytest tests >/dev/null 2>&1; then
            test_success=true
        fi
    fi
    
    # Strategy 6: Python unittest (fallback, no coverage)
    if [[ "$test_success" == false ]]; then
        if $PYTHON_CMD -m unittest discover tests >/dev/null 2>&1; then
            test_success=true
        fi
    fi
    
    if [[ "$test_success" == true ]]; then
        # Show coverage report if available
        if [[ -n "$coverage_cmd" ]]; then
            coverage_report=$($coverage_cmd report -m)
            echo "$coverage_report"
            
            percent=$(echo "$coverage_report" | grep -E '^TOTAL' | awk '{print $NF}' | tr -d '%')
            
            if [[ -n "$percent" ]]; then
                if (( percent < 80 )); then
                    log_error "Test coverage ${percent}% is below required 80%."
                    exit 1
                fi
                log_info "All tests passed. ${percent}% coverage achieved."
            else
                log_info "All tests passed. Coverage report generated."
            fi
        else
            log_info "All tests passed."
        fi
        exit 0
    else
        log_error "Some tests failed."
        exit 1
    fi
}

# Process URLs with robust error handling
process_urls() {
    local file="$1"
    local status=0

    if [[ ! -f "$file" ]]; then
        log_error "URL file not found: $file"
        exit 1
    fi

    log_info "Processing URLs from $file..."
    
    PYTHON_CMD=$(find_python)

    while IFS= read -r url; do
        [[ -z "$url" || "$url" =~ ^# ]] && continue
        log_info "Processing: $url"

        if [[ "$url" =~ huggingface\.co/datasets/ ]]; then
            # Extract dataset ID
            if [[ "$url" =~ huggingface\.co/datasets/([^/]+/[^/]+) ]]; then
                id="${BASH_REMATCH[1]}"
            elif [[ "$url" =~ huggingface\.co/datasets/([^/]+) ]]; then
                id="${BASH_REMATCH[1]}"
            fi
            id=$(echo "$id" | sed 's|/$||' | tr -d '\r')
            
            # Try multiple execution strategies
            local cmd_success=false
            if $PYTHON_CMD -m src.ai_model_catalog hf-dataset --dataset-id "$id" --format ndjson 2>/dev/null; then
                cmd_success=true
            elif $PYTHON_CMD -m ai_model_catalog hf-dataset --dataset-id "$id" --format ndjson 2>/dev/null; then
                cmd_success=true
            fi
            
            if [[ "$cmd_success" == false ]]; then
                log_error "Failed to process dataset URL: $url"
                status=1
            fi

        elif [[ "$url" =~ huggingface\.co/[^/]+/[^/]+ ]] && [[ ! "$url" =~ huggingface\.co/datasets/ ]]; then
            # Extract model ID
            id=$(echo "$url" | sed -E 's|.*huggingface\.co/([^/]+/[^/]+).*|\1|' | tr -d '\r')
            
            # Try multiple execution strategies
            local cmd_success=false
            if $PYTHON_CMD -m src.ai_model_catalog hf-model --model-id "$id" --format ndjson 2>/dev/null; then
                cmd_success=true
            elif $PYTHON_CMD -m ai_model_catalog hf-model --model-id "$id" --format ndjson 2>/dev/null; then
                cmd_success=true
            fi
            
            if [[ "$cmd_success" == false ]]; then
                log_error "Failed to process model URL: $url"
                status=1
            fi

        elif [[ "$url" =~ github\.com ]]; then
            # Extract repo info
            repo_path=$(echo "$url" | sed -E 's|.*github\.com/([^/]+/[^/]+).*|\1|' | tr -d '\r')
            owner=$(echo "$repo_path" | cut -d/ -f1)
            repo=$(echo "$repo_path" | cut -d/ -f2)
            
            # Try multiple execution strategies
            local cmd_success=false
            if $PYTHON_CMD -m src.ai_model_catalog models --owner "$owner" --repo "$repo" --format ndjson 2>/dev/null; then
                cmd_success=true
            elif $PYTHON_CMD -m ai_model_catalog models --owner "$owner" --repo "$repo" --format ndjson 2>/dev/null; then
                cmd_success=true
            fi
            
            if [[ "$cmd_success" == false ]]; then
                log_error "Failed to process GitHub URL: $url"
                status=1
            fi

        else
            log_warn "Unsupported URL format: $url"
        fi
    done < "$file"

    if [[ $status -eq 0 ]]; then
        log_info "All URLs processed successfully."
    else
        log_error "Some URLs failed to process."
    fi

    exit $status
}

main() {
    check_python

    case "${1:-}" in
        install)
            install_deps
            ;;
        test)
            run_tests
            ;;
        "")
            log_error "No command provided. Use: ./run install | test | <url_file.txt>"
            exit 1
            ;;
        *)
            process_urls "$1"
            ;;
    esac
}

main "$@"